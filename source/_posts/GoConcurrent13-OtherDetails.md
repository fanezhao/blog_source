---
title: Go并发编程（十三）调度器的其他细节
date: 2020-05-22 21:00:00
tags:
  - Go
---

> 调度器是Go运行时系统中最重要的模块。我们再聊一些它的其他细节。

## g0和m0

运行时系统中的每个M都会拥有一个特殊的G，一般称为M的**g0**。M的g0管辖的内存称为M的**调度栈**。可以说，M的g0对应于操作系统为相应线程创建的栈。因此M的调度栈也可以称为OS线程栈或系统栈（参见`runtime.systemstack`函数）。

M的g0是由Go运行时系统在初始化M的时创建并分配给该M的。M的g0一般用于执行调度、垃圾回收、栈管理等方面的任务。

> BTW，M还会拥有一个专门用于处理信号的G，称为`gsignal`。它的栈可称为信号栈。系统栈和信号栈不会自动增长，但一定会有足够的空间执行代码。

除了g0之外，其它由M运行的G都可以视作用户级别的G，简称**用户G**，这些M的g0和`gsignal`都可以称为**系统G**。Go运行时系统会进行切换，以使每个M都能运行用户G和它的g0。与用户G不同，g0不会被阻塞，也不会包含在任何G队列或列表中。还有，它的栈也不会在垃圾回收的期间被扫描。

除了每个M都拥有属于它自己的g0之外，还存在一个`runtime.g0`。`runtime.g0`用于执行引导程序，它运行在Go程序拥有的第一个内核线程中，这个内核线程也称为`runtime.m0`。`runtime.m0`和`runtime.g0`都是静态分配的，因此引导程序无需为它们分配内存。`runtime.m0`的g0即`runtime.g0`。

## 调度器锁和原子操作

>  前面两三篇文章中很多流程都用到了调度器锁。

每个M都可能执行调度任务，这此任务在时间上可能存在冲突，即并发的调度。因此调度器会在读写一些全局变量以及它的字段的时候动用调度器锁进行保护。

例如， 在对核心元素容器（如`runtime.allp`和`runtime.sched.runqhead`）中的元素进行存取，以及修改相应计数器（即`sched.stopwait`和`sched.nmidle`等）时，都会锁定调度器锁。其中`sched.nmidle`用于对空闲的M进行计数。

此外，Go运行时系统在一些需要保证并发安全的变量的存取上使用了原子操作。众所周知，原子操作要比锁操作轻量很多，相对的更能节省系统资源和提升系统性能。

例如，在对`sched.nmspinning`（对正在自旋的M进行计数）、`sched.ngsys`（对系统G进行计数）等变量读写时会用到原子操作。又例如，在转换某个G的状态时也会用到原子操作。

调度器在自身的并发执行上做了很多有效的约束和控制，兼顾正确性和可伸缩性。

## 调整GC

目前，Go的GC是基于**CMS（Concurrent Mark-Sweep，并发的标记-清扫）算法**的。未来也有改用更高效GC算法的可能。Go的GC也是非分代的和非压缩的。

当前的GC有3种执行模式，如下：

- **gcBackgroundMode**：并发的执行垃圾收集（标记）和清扫。
- **goForceMode**：串行的执行垃圾收集（即执行时停止调度），但并发的执行清扫。
- **goForceBlockMode**：串行的执行垃圾收集清扫。

调度器驱使的自动GC和系统监测任务中的强制GC，会以`gcBackgroundMode`模式执行。但是前者会检查Go程序当前的内存使用量，仅当使用增量过大时才会真正执行GC。然而，后者会无视这个前提条件。

我们可以通过环境变量`GODEBUG`控制自动GC的并发性。只要使其值包含`gcstoptheworld=1`或`gcstoptheworld=2`，就可以让GC的执行模式由`gcBackgroundMode`变成`goForceMode`或`goForceBlockMode`，这相当于让并发进入调试模式。

简单来讲，GC会在为Go程序分配的内存翻倍增长时被触发。Go运行时系统会在分配新内存时检查Go程序的内存使用量。我们可以通过调用`runtime/debug.SetGCPercent`函数改变这个增量的阈值。

`SetGCPercent`函数接受一个`int`类型的参数，其含义是：**在新分配的内存是上次记录的已分配内存的百分之几时触发GC**。显然，这个参数不应该是负数，否则会导致自动GC的关闭；**Go运行时系统对此的预设值是100**。另外，`SetGCPercent`会返回旧的增量阈值。

设置环境变量`GOGC`也可以达到同样的效果，其值的含义和设置规则也与`SetGCPercent`函数相同。另外把`GOGC`的值设置为`off`也会关闭自动GC。不过要注意，和`GODEBUG`一样，对`GOGC`的设置需要在Go程序启动之前进行，否则不生效。

关闭自动GC请意味着我们要在程序中手动GC了。调度`runtime.GC`函数可以手动触发一次GC，不过会阻塞调用方直到GC完成。注意，这种模式下的GC会以`goForceBlockMode`模式执行。此外，调用`runtime/debug`包的`FreeOSMemory`函数也可以手动触发一次完全串行的GC，并且在GC完成后还会做一次清扫堆的操作。还有，这两者在执行时都不会检查Go程序的内存使用增量。

## 总结

好了，上面就先总结了Go调度器的三个其他的细节。