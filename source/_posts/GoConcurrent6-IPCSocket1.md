---
title: Go并发编程（六）IPC之socket基础
tags:
  - Go
date: 2020-04-24 14:18:00
---


> socket常译为套接字，也是一种IPC方法。但是与其它IPC方法不同的是，它可以通过网络连接让多个进程之间建立通信并相互传递数据，这使得通信双方是否在同一台计算机上变得无关紧要。

## socket的基本特性

大多数操作系统都包含了`socket`接口的实现，主流以及新兴的编程语言也都支持`socket`，Go当然也不例外。

以Linux系统为例，简单说下其`socket`接口的实现。在Linux中，存在一个名为`socket`的系统调用，声明如下：

```c
int socket(int domain, int type, int protocol);
```

该系统调用的功能是创建一个`socket`实例。它接收3个参数，分别代表这个`socket`的**通信域、类型和所用协议**。

### socket的通信域

每个`socket`都必将存在于一个通信域中，而通信域决定了该`socket`的地址格式和通信范围。`socket`通信域参见下表：

| 通信域   | 含义   | 地址形式 | 通信范围                                           |
| -------- | ------ | -------- | -------------------------------------------------- |
| AF_INET  | IPv4域 | IPv4地址 | 基于IPv4协议的网络中任意两台计算机上的两个应用程序 |
| AF_INET6 | IPv6域 | IPv6地址 | 基于IPv6协议的网络中任意两台计算机上的两个应用程序 |
| AF_UNIX  | Unix域 | 路径名称 | 在同一台计算机上的两个应用程序                     |

由上表可知，Linux提供的`socket`通信域有三个，即`AF_INET`、`AF_INET6`和`AF_UNIX`，它们分别代表了IPv4域、IPv6域和Unix域。这三个域的标识符都是以`AF_`为前缀。AF是address family的缩写，意为**地址族**，这也暗示了每个域的`socket`地址格式不同。另外，不同的是IPv4域和IPv6域的通信是在网络范围内的，而Unix域的通信则是在单台计算机范围内。

### socket的类型

`socket`的类型有很多，这些类型及其特性如下表所示：

| 特性\类型  | SOCK_DGRAM | SOCK_RAW | SOCK_SEQPACKET | SOCK_STREAM |
| ---------- | ---------- | -------- | -------------- | ----------- |
| 数据形式   | 数据报     | 数据报   | 字节流         | 字节流      |
| 数据边界   | 有         | 有       | 有             | 没有        |
| 逻辑连接   | 没有       | 没有     | 有             | 有          |
| 数据有序性 | 不能保证   | 不能保证 | 能够保证       | 能够保证    |
| 传输可靠性 | 不具备     | 不具备   | 具备           | 具备        |

**数据形式和数据边界**

数据形式有两种：数据报和字节流。

- 以数据报为数据形式意味着数据接收方的`socket`接口程序可以意识到数据的边界，并对它们进行切分，这样就省去了接收方应用程序寻找数据边界和切分数据的工作量。

- 以字节流为数据形式的数据传输实际上传输的是一个字节接着一个字节的串，我们可以把它想像成一个字节数组。一般情况下，字节流并不能体现出哪些字节属于哪个数据包。因此，`socket`接口程序是无法从中分离出独立的数据包，这一工作只能由数据接收方的应用程序去完成。然而，`SOCK_SEQPACKET`类型的`socket`接口程序是例外的。

> 数据边界就是应用程序每次发送字节流片段之间的分界点，这些数据边界信息会随着字节流一同发往数据接收方。数据发送方的`socket`接口程序可以记录数据边界。数据接收方的`socket`接口会根据数据边界把字节流切分成若干个字节流片段并按照需要依次传递给应用程序。

**逻辑连接**

在面向有连接的`socket`之间传输数据之前，必须先建立逻辑连接。在连接建好之后，通信双方才能很方便的互相传输数据。并且，由于双方已经暗含了双方的地址，所以在传输数据的时候不必再指定目标地址。

两个面向有连接的`socket`之间一旦建立连接，那么它们发送的数据就只能发送到连接的一端。然而，面向无连接的`socket`则完全不同，这类`socket`在通信时无需建立连接。它们传输的每个数据包都是独立的，并且会直接发送到网络上。这些数据包中都含有目标地址，因此每个数据包都可能传输至不同的目的地。此外，面向无连接的`socket`数据流只能是单向的，不能既发送数据又接收数据。

**数据有序性和传输可靠性**

数据的有序性和可靠性与`socket`是否面向连接有很大关系。正是因为逻辑连接的存在，通信双方才有条件通过一些手段来保证数据发送方发送的数据能够及时、正确、有序的到达数据接收方，并被数据接收方接受。

### socket的所用协议

在调用系统调用`socket`的时候，一般会把0作为第三个参数值，其含义是让操作系统内核根据第一个和第二个参数的值自行决定`socket`所使用的协议，这意味着`socket`的通信域和类型与所用协议之间是存在对应关系的：

| 通信域\类型 | SOCK_DGRAM | SOCK_RAW | SOCK_SEQPACKET | SOCK_STREAM |
| -------- | ---------- | -------- | -------------- | ----------- |
| AF_INET  | UDP        | IPv4     | SCTP           | TCP或SCTP   |
| AF_INET6 | UDP        | IPv6     | SCTP           | TCP或SCTP   |
| AF_UNIX  | 有效       | 无效     | 有效           | 有效        |

在上表中，TCP（Transmission Control Protocol，传输控制协议）、UDP（User Datagram Protocol，用户数据报协议）和SCTP（Stream Control Transmission Protocol，流控制传输协议）都是`TCP/IP`协议栈中的传输协议，而IPv4和IPv6则分别代表了`TCP/IP`协议栈中的网络互连层协议`IP`（Internet Protocol，网际协议）的第四个版本和第六个版本。

“有效”表示该通信域和类型的组合会使内核选择某个内部的`socket`协议。“无效”则表示该通信域和类型的组合是不合法的。

在Go提供的`socket`编程API中，也会涉及这些组合，并有一些专门的字面量来表示，在后面会讲到。

### socket的返回值

在系统调用`socket`函数没有发生任何错误的情况下，会返回一个`int`类型的值，该值是`socket`实例唯一标识符的文件描述符，一旦得到该描述符，就可以调用其它系统操作来进行各种相关操作了，比如绑定和监听端口、发送和接收数据以及关闭`socket`实例等等。这里就不过多介绍那些系统调用的用法了。

## 基于TCP/IP协议栈的socket通信模型

前面我们说通过系统调用来使用操作系统提供的`socket`接口，其实`socket`接口程序与`TCP/IP`协议栈的实现程序一样，是Linux内核的一部分。

socket接口既可以提供网络中不同计算机上多个应用程序间的通信支持，也可以成为单台计算机上多个应用程序间的通信手段。不过使用`socket`接口的绝大多数情况都是为了在网络中进行通信，这样的通信是基于`TCP/IP`协议栈的。`socket`接口与`TCP/IP`协议栈、操作系统内核的关系如下图所示。

{% qnimg scoket接口与TCP_IP协议栈、操作系统内核的关系.jpg %}

在`socket`通信中，一般会包含了两个概念上独立的程序，即服务端和客户端程序。服务端程序会在一个给定的端口是监听`TCP`连接，而客户端程序会试图与这个服务端建立`TCP`连接并进行通信。下图是客户端和服务端的简单通信流程图：

{% qnimg TCP通信简单流程.jpg %}

这张流程图展现了客户端与服务端通过操作系统的`socket`接口建立`TCP`连接并进行简单通信的一般情形。前面说过`TCP`协议是一种面向有连接的协议，当客户端和服务端建立好连接之后，在数据传输的过程中就不用重复建立连接了，直接发送和接收数据即可，所以虚线框中的流程，一般会循环多次。

## 常用API

为了使用Go实现上面的服务端和客户端程序，这里先介绍一下标准库代码包`net`中的常用API。

### 服务端

服务端首先会用到下面这个函数：

```go
func Listen(network, address string) (Listener, error)
```

这个函数是用于获取监听器，它接受两个参数。

- **`network`的含义是以何种协议监听给定的地址**，在Go中，这些协议由一些字符串字面量来表示：

  - "tcp"：代表 TCP 协议，其基于的 IP 协议的版本根据参数address的值自适应。
  - "tcp4"：代表基于 IP 协议第四版的 TCP 协议。
  - "tcp6"：代表基于 IP 协议第六版的 TCP 协议。
  - "udp"：代表 UDP 协议，其基于的 IP 协议的版本根据参数address的值自适应。
  - "udp4"：代表基于 IP 协议第四版的 UDP 协议。
  - "udp6"：代表基于 IP 协议第六版的 UDP 协议。
  - "unix"：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_STREAM 为 socket 类型。
  - "unixgram"：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_DGRAM 为 socket 类型。
  - "unixpacket"：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_SEQPACKET 为 socket 类型。

  这些字面量就是上面在讲Linux的系统调用`socket`函数的所用协议是提到的字面量。

- **`address`的含义表示当前程序在网络中的标识**，格式是“host:port”，也就是我们常说的IP和端口号。例如：127.0.0.1:8080。

`net.Listen`函数被调用之后，有两个返回值，第一个返回值是`net.Listener`类型的，它代表的就是监听器。第二个返回值是一个`error`类型的值，代表获取监听器是否发生错误，记得一定要先判断该值是否为`nil`。

如果获取监听器没有问题的话，就可以等待客户端的连接请求了，方法如下：

```go
conn, err := listener.Accept()
```

当调用监听器的`Accept`方法时，流程会被阻塞，直到某个客户端与当前程序建立`TCP`连接。此时`Accept`方法会返回两个返回值：第一个代表当前`TCP`连接的`net.Conn`类型的值，就是通信建立成功之后的连接。第二个还是一个`error`类型的值，表示在建立连接的过程中是否发生错误。

### 客户端

`net`代码包中的`Dial`函数用于向指定的网络地址发送连接建立申请，它的声明如下：

```go
func Dial(network, address string) (Conn, error)
```

函数`net.Dial`函数也接受两个参数：

- 其中，`network`与`net.Listen`函数的第一个参数含义非常类似，但是它拥有更多可选值，因为在发送数据之前不一定要先建立连接。

- 第二个参数`address`与`net.Listen`函数的第二个参数完全一致。如果相与前面刚刚监听的服务端程序连接的话，那么这个参数就应该是服务端的地址，这不难理解。

这里你可能会问：**客户端自己的地址在哪里给出呢？**答案是根本不用给出。客户端的使用端口号可以由应用程序指定，也可以由操作系统内核动态分配。

函数`net.Dial`函数也有两个返回值：

- 一个是`net.Conn`类型的值，就是我们建立好的连接。

- 一个是`error`类型的值，如果建立连接的过程顺利的话，这个值应该是nil。

### 超时时间

另外再说一点，要知道，网络中是存在延时现象的。因此，在收到另一方的有效响应（无论是连接成功或失败）之前，发送连接请求的往往会等待一段时间。例如，客户端程序会在调用`net.Dail`这行代码上阻塞。在超过这个等待时间后，函数的执行就会结束并返回相应的`error`类型的值。因此，这类等待时间也常称为**超时（timeout）时间**。

不同操作系统对基于不同协议的连接请求的超时时间都有不同的设定。例如，在Linux操作系统内核中，把基于`TCP`协议的连接请求的超时时间设定为75s。

在很多应用场景中，固定不变的超时时间往往无法满足需求。因此操作系统内核也提供了改变这类时间的接口，在Go的`net`代码包中也有对应的API。

```go
func DialTimeout(network, address string, timeout time.Duration) (Conn, error)
```

`net.DialTimeout`函数的第三个参数，就是用于设定超时时间的，单位是纳秒。

### 连接

到这里，我们学习的这几个API足以在客户端和服务端建立起`TCP`连接了。当连接建立成功之后，不论是客户端还是服务端程序，都会获取一个`net.Conn`类型的值，也就是我们说的建立好的连接。

`net.Conn`是一个接口类型，在它的方法集合中包含了8个方法，它们定义了可以在一个连接上做的所有事情。接下来，我们对它们逐一说明：

- **Read方法**：该方法接受一个`[]byte`类型的参数，该参数用来相当于一个用来存放从连接上接收到数据的容器，它的长度完全由我们自定义。`Read`方法会把它当成空的容器填满，该容器的相应位置上的原元素将会被替换。所以，我们每次应该让这个容器在填充之前保持绝对干净。

  `Read`的第一个返回值n代表本次操作实际读取到的字节个数，也可以把它理解为`Read`方法向参数值中填充的字节个数。可以这样使用它：

  ```go
  b := make([]byte, 10)
  n, err := conn.Read(b)
  content := string(b[:n])
  ```

  如果`socket`编程API程序在从`socket`的接收缓冲区中读取数据时发现`TCP`连接已经被另一端关闭了，就会立即返回一个error类型的值。这个error类型的值与`io.EOF`是相等的。其中**`io.EOF`象征文件内容的完结**，若该值为`io.EOF`则意味着在此`TCP`连接之上再无可读取的数据。也可以说，该`TCP`连接已经无用，可以关闭了。

- **Write方法**：write方法用于向`socket`的发送缓冲区写入数据，方法声明如下：

  ```go
  Write(b []byte) (n int, err error)
  ```

  该方法接受一个字节数组类型的参数，返回一个`int`类型和`error`类型的值，其中`n`代表本次实际写入的字节数量。

- **Close方法**：`Close`方法会关闭当前连接，它不接受任何参数并返回一个`error`类型的值。调用该方法之后，对该连接值上的`Read`方法、`Write`方法或`Close`方法的任何调用都会使它们立即返回一个`error`类型值。

  另外，如果此时`Close`方法，`Read`方法或`Write`方法正在被调用且还未执行结束，那么它们也会立即结束并返回一个不为`nil`的`error`类型的值，即使它们处于阻塞状态，也会这样。

- **LocalAddr和RemoteAddr**：它们都不接受任何参数并返回一个`net.Addr`类型的结果。其结果值代表了参与当前通信的某一端在网络中的地址。显然，`LocalAddr`方法的返回值代表了本地地址，而`RemoteAddr`方法的返回值代表了远程地址。

  `net.Addr`类型是一个接口类型，它有两个方法`Network`和`String`。前者会返回当前连接使用的协议名称，例如：

  ```go
  conn.LocalAddr.Network()
  ```

  会返回一个类型"tcp"的值。

  `String`方法会返回一个地址，这个地址与前面说到的各个通信域下的地址表现形式和格式是对应的。如果基于`TCP`协议的服务端程序，它的地址格式就是“host:port”，比如：“127.0.0.1:8080”。

- **SetDeadline、SetReadDeadline和SetWriteDeadline**：这三个方法都只接受一个`time.Time`类型值作为参数，并返回一个`error`类型的结果值。

  `SetDeadline`方法会设定当前连接上的I/O操作（包括但不限于读和写）的超时时间。**注意，这里的超时时间是一个绝对时间！**也就是说，如果调用`SetDeadline`方法之后的相关I/O操作到达此超时时间还没完成，那么它们就会立即结束并返回一个非`nil`的错误值。这个`error`类型的值被预置在了代码包中，其提示信息为“i/o timeout”。还有，当你以循环的方式从一个连接上读取数据时，需要在每次读取的数据之前都重新设定一次，因为这个时间是绝对时间，从设定的那一刻开始计时，如果不每次重新设定，就有可能在循环未结束的时候时间就超时了。

  另外，如果想取消超时，只需传入`time.Time`类型的零值，即传入`time.Time{}`即可。

  `SetReadDeadline`和`SetWriteDeadline`它们俩分别针对于读操作（与连接的`Read`方法的调用对应）和写操作（与连接的`Write`方法的调用对应）。对于写操作，有一个问题需要明确，就是即使一个写操作超时了，也不一定表示这个写操作完全没有成功。因为在超时之前，`Write`方法可能已经将一部分数据写入`socket`的缓冲区了。也就是说，即使`Write`方法因为超时时间而被迫停止，那它的第一个返回值也可能大于0，说明还是有一部分数据被写入了。

  `SetDeadline`调用相当于先后以同样的参数调用`SetReadDeadline`和`SetWriteDeadline`方法，粒度不同，可以根据实际情况使用。

## 总结

这篇文章我们主要学习与socket有关的知识，包括socket的基本特性：通信域、类型、所用协议等，还额外介绍了Linux中socket的通信模型， 最后还介绍了在Go中支持socket的相关API。通过这些，相信我们已经大致了解了socket，后面我会通过一个具体的例子贯穿这些知识，加深理解。

## 链接

[具体的例子](http://zmoyi.com/2020/04/24/GoConcurrent7-IPCSocket2/)

